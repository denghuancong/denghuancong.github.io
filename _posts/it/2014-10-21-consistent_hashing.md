---
layout: post
title:  "一致性Hash"
date:   2014-10-22 00:40:33
categories: 
	- it
---


	去年工作的时候听大智慧的架构师的演讲，第一次听到一致性hash这个名词，当时没听明白，
	后面工作没联系到这个东西，后来也没去追查了，但了今年，听存储的同事的演讲，
	也听到这个名词，然后就有了这篇文章。

#### 背景

一般的分布式缓存系统是这样设计的，有好几台内存比较大的服务器作为缓存服务器，
假如3台，node1，node2，node3，业务程序需要把频繁访问的热点数据存储在
缓存服务器中以减少对下层DB的压力，这时，假如写数据（“test”，"{a:1,b:2}"）
, 缓存系统内部的过程是这样的：
	
	1.向缓存系统的路由组件根据hash算法，算出key（也就是text）的hash值，
	然后用这个hash值余3的出一台缓存服务器，假如这里得到node2
	2.缓存系统将这个路由信息记录下来，以便下次访问
	3.返回给业务程序node2这个节点的信息

然后，业务程序就把这个数据往node2这个节点写（至于用什么协议，可以自定，
假如Memcached，redis等），下次需要读取数据的时候，读操作过程简单可以认为是这样的：
	
	1.根据key从缓存系统的路由组件获取这个key对应的node节点信息
	2.返回给业务程序

这样就可以马上知道是node2这个节点，立刻进行读操作，无需再访问DB，起到加速的作用。
但后面业务发展迅猛，需要增加了1台缓存服务器，这时，缓存服务器的数量就变成4了，
路由计算也需要使用4昨晚被除数重算计算hasn值，这样前面三台缓存服务器的路由信息就
起不到原来的左右，所有数据都会走到DB去访问并重新缓存，起不到原来需要的效果。

#####那有什么方法可以处理尼？
	
	本质上就是需要在新增服务器的时候尽量减少对已上线服务器的影响，也就是尽量
	减少路由信息失效的范围

#### 一致性hash（Consistent hashing）

	答案就是引入一致性hash算法来做路由计算，先构造一个0-2的32次方的环，然后
	将缓存服务器id（假如cache A）根据hash算出一个数值，这个数值也是0-2的32次方
	的范围，并投射在这个环上，类似，cache B 和cache C同样用这个方式投射到这个大环
	上面，当业务程序需要把写缓存数据时，讲key进行hash得到一个0到2的32次方之间的
	hash值（key 1），并投射到这个环上面，然后顺时针找到cache A，因此就返回cache A
	的信息，这样的做法的好处时，下次有新服务器加入时，例如cache D，计算得出的hash值
	投放到cache A 和 cache B直接，那么原来在cache A到cache b直接的某一部分
	（cache A到cache D的这部分）路由信息会失效，而其他的别的路由信息都可以继续
	正常使用，但这样由于新增的服务器减低了cache B的负载（一部分负载都到cache D了），
	而cache A和cache C的负载还是很高，这样所有服务器的负载就很不平衡，因此我们采取
	下面的方式进一步优化这个方案。
	
![Consistent_hashing]({{ site.url }}/images/Consistent_hashing.jpg)

##### 虚拟节点

	上面提到的不足的主要原因是因为节点数量在比较少的情况下才会发生的，因此下面的
	解决方案是增加缓存服务器的节点数量，但服务器非常昂贵，增加是非常有限的，因此
	现在的方案是把一个物理节点虚拟为多个虚拟节点，如下图，新增服务器时，都按照这样
	的方式，把虚拟节点映射到hash环上面去，这样hash key的值分布就会比较均很到散落
	在这些物理服务器上面去。

![Consistent_hashing]({{ site.url }}/images/Consistent_hashing_virtual_node.png)
